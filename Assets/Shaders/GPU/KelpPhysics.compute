#pragma kernel CS_VerletUpdate            // stalk
#pragma kernel CS_ApplyConstraints        // stalk
#pragma kernel CS_VerletUpdateLeaves      // NEW: leaf segments verlet
#pragma kernel CS_ApplyLeafConstraints    // NEW: leaf segments constraints + root attach
#pragma kernel CS_UpdateLeaves            // per-leaf orientation/bend from rope

struct StalkNode
{
    float3 currentPos;  float pad0;
    float3 previousPos; float pad1;
    float3 direction;   float pad2;
    float4 color;
    float  bendAmount;  float3 pad3;
    int    isTip;       float3 pad4;
};

struct LeafSegment
{
    float3 currentPos;  float pad0;
    float3 previousPos; float pad1;
    float4 color;
};

struct LeafObject
{
    float4 orientation;     // 16
    float3 bendAxis;        // 12
    float  bendAngle;       // 4
    int    stalkNodeIndex;  // n0 attachment
    float  angleAroundStem;
    float2 pad;
};

// ---------- Buffers ----------
RWStructuredBuffer<StalkNode>   _StalkNodesBuffer;
StructuredBuffer<float3>        initialRootPositions;

RWStructuredBuffer<LeafSegment> _LeafSegmentsBuffer;  // totalLeafObjects * _LeafNodesPerLeaf
RWStructuredBuffer<LeafObject>  _LeafObjectsBuffer;

// ---------- Params ----------
float  _DeltaTime;
float3 _Gravity;
float  _Damping;
float  _SegmentSpacing;
float  _Time;
float  _WindStrength;
float  _WindFrequency;
float _StemRadius;
float  _LeafGravity = 0.47; 

uint   _NodesPerStalk;
uint   _LeafNodesPerLeaf;
uint   _TotalLeafObjects;

// ---------- Noise / helpers ----------
float hash(float3 p) { return frac(sin(dot(p, float3(127.1,311.7,74.7))) * 43758.5453); }

uint hashU(uint x){
    x = (x ^ 61u) ^ (x >> 16);
    x *= 9u; x = x ^ (x >> 4);
    x *= 0x27d4eb2du; x = x ^ (x >> 15);
    return x;
}

static const float3 grad3[12] = {
    float3(1,1,0), float3(-1,1,0), float3(1,-1,0), float3(-1,-1,0),
    float3(1,0,1), float3(-1,0,1), float3(1,0,-1), float3(-1,0,-1),
    float3(0,1,1), float3(0,-1,1), float3(0,1,-1), float3(0,-1,-1)
};

float fade(float t){ return t*t*t*(t*(t*6-15)+10); }

float gradNoise3D(float3 pos){
    int3 pi = (int3)floor(pos);
    float3 pf = pos - floor(pos);
    float u = fade(pf.x), v = fade(pf.y), w = fade(pf.z);

    uint aaa = hashU(hashU(hashU((uint)pi.x)+(uint)pi.y)+(uint)pi.z)%12;
    uint aba = hashU(hashU(hashU((uint)pi.x)+(uint)(pi.y+1))+(uint)pi.z)%12;
    uint aab = hashU(hashU(hashU((uint)pi.x)+(uint)pi.y)+(uint)(pi.z+1))%12;
    uint abb = hashU(hashU(hashU((uint)pi.x)+(uint)(pi.y+1))+(uint)(pi.z+1))%12;
    uint baa = hashU(hashU(hashU((uint)(pi.x+1))+(uint)pi.y)+(uint)pi.z)%12;
    uint bba = hashU(hashU(hashU((uint)(pi.x+1))+(uint)(pi.y+1))+(uint)pi.z)%12;
    uint bab = hashU(hashU(hashU((uint)(pi.x+1))+(uint)pi.y)+(uint)(pi.z+1))%12;
    uint bbb = hashU(hashU(hashU((uint)(pi.x+1))+(uint)(pi.y+1))+(uint)(pi.z+1))%12;

    float3 gaaa=grad3[aaa], gaba=grad3[aba], gaab=grad3[aab], gabb=grad3[abb];
    float3 gbaa=grad3[baa], gbba=grad3[bba], gbab=grad3[bab], gbbb=grad3[bbb];

    float x1 = lerp(dot(gaaa,pf),                  dot(gbaa,pf-float3(1,0,0)), u);
    float x2 = lerp(dot(gaba,pf-float3(0,1,0)),    dot(gbba,pf-float3(1,1,0)), u);
    float y1 = lerp(x1, x2, v);

    float x3 = lerp(dot(gaab,pf-float3(0,0,1)),    dot(gbab,pf-float3(1,0,1)), u);
    float x4 = lerp(dot(gabb,pf-float3(0,1,1)),    dot(gbbb,pf-float3(1,1,1)), u);
    float y2 = lerp(x3, x4, v);

    return lerp(y1, y2, w);
}

// quaternions (avoid name clash with HLSL normalize)
float4 QuatFromAxisAngle(float3 axis, float angle){
    float h=angle*0.5; float s=sin(h);
    return float4(axis*s, cos(h));
}
float4 QuatMul(float4 a, float4 b){
    return float4(
        a.w*b.xyz + b.w*a.xyz + cross(a.xyz,b.xyz),
        a.w*b.w - dot(a.xyz,b.xyz)
    );
}
float3 QuatRotate(float4 q, float3 v){
    float3 t = 2.0 * cross(q.xyz, v);
    return v + q.w * t + cross(q.xyz, t);
}
float4 QuatFromTo(float3 f, float3 t){
    f = normalize(f); t = normalize(t);
    float c = dot(f,t);
    if(c < -0.9999){
        float3 axis = normalize(cross(float3(0,1,0), f));
        if(!all(isfinite(axis)) || length(axis)<1e-6) axis = normalize(cross(float3(1,0,0), f));
        return QuatFromAxisAngle(axis, 3.14159265);
    }
    float3 axis = cross(f,t);
    float s = sqrt((1+c)*2.0);
    float invs = 1.0/s;
    float4 q = float4(axis*invs, s*0.5);
    return q / sqrt(dot(q,q));
} 

// ---------- Stalk: Verlet ----------
[numthreads(64,1,1)]
void CS_VerletUpdate(uint id : SV_DispatchThreadID)
{
    if (id >= _StalkNodesBuffer.Length) return;

    StalkNode node = _StalkNodesBuffer[id];

    // root of each stalk pinned to initialRootPositions
    if (id % _NodesPerStalk == 0){
        uint stalkIndex = id / _NodesPerStalk;
        node.currentPos  = initialRootPositions[stalkIndex];
        node.previousPos = node.currentPos;
        node.direction = float3(0,1,0);
        node.bendAmount = 0;
        _StalkNodesBuffer[id] = node;
        return;
    }

    float3 velocity = (node.currentPos - node.previousPos) * _Damping;
    node.previousPos = node.currentPos;

    // smooth wind
    float3 np = float3(id*0.1, 0, 0) + float3(0, _Time*_WindFrequency, 0);
    float3 wind = float3(
        gradNoise3D(np + float3(0,0,0)),
        gradNoise3D(np + float3(20,20,20)), 
        gradNoise3D(np + float3(100,100,100))
    ) * _WindStrength;

    node.currentPos += velocity + (_Gravity * _DeltaTime) + wind * _DeltaTime;

    // seabed collision
    if (node.currentPos.y < 0){
        float3 vel = node.currentPos - node.previousPos;
        node.currentPos.y = 0;
        vel.y = 0;
        node.previousPos = node.currentPos - vel * _Damping;
    }

    // smoothed direction & bend
    bool hasPrev = (id % _NodesPerStalk) != 0;
    bool hasNext = ((id + 1) % _NodesPerStalk) != 0 && (id + 1) < _StalkNodesBuffer.Length;

    float3 prevDir = float3(0,1,0);
    float3 nextDir = float3(0,1,0);

    if (hasPrev) prevDir = normalize(node.currentPos - _StalkNodesBuffer[id-1].currentPos);
    if (hasNext) nextDir = normalize(_StalkNodesBuffer[id+1].currentPos - node.currentPos);

    float3 targetDir = normalize(prevDir + nextDir);
    node.direction = normalize(lerp(node.direction, targetDir, 0.2));
    node.bendAmount = length(nextDir - prevDir) * 5.0;

    _StalkNodesBuffer[id] = node;
} 

// ---------- Stalk: Constraints ----------
[numthreads(64,1,1)]
void CS_ApplyConstraints(uint id : SV_DispatchThreadID)
{
    if (id >= _StalkNodesBuffer.Length) return;
    if (id % _NodesPerStalk == 0) return; // root pinned

    // ensure same stalk
    if ((id / _NodesPerStalk) != ((id-1) / _NodesPerStalk)) return;

    StalkNode a = _StalkNodesBuffer[id-1];
    StalkNode b = _StalkNodesBuffer[id];

    float3 d = b.currentPos - a.currentPos;
    float dist = length(d);
    if (dist < 1e-6) d = float3(0,1,0), dist = 1.0;

    float diff = dist - _SegmentSpacing;
    if (abs(diff) > 1e-5){
        float3 corr = (d / dist) * (diff * 0.5);
        // move both, except keep the root fixed
        b.currentPos -= corr;
        if (((id-1) % _NodesPerStalk) != 0){
            a.currentPos += corr;
            _StalkNodesBuffer[id-1] = a;
        }
        _StalkNodesBuffer[id] = b;
    }
} 

// ---------- LEAF ROPE: Verlet (per segment) ----------
[numthreads(64,1,1)]
void CS_VerletUpdateLeaves(uint id : SV_DispatchThreadID)
{
    if (id >= _LeafSegmentsBuffer.Length) return;

    LeafSegment s = _LeafSegmentsBuffer[id];

    // standard verlet velocity
    float3 vel = (s.currentPos - s.previousPos) * _Damping * 0.7;
    s.previousPos = s.currentPos;

    // gentle wind
    float3 np = float3(id*0.07, 0, 0) + float3(0, _Time*_WindFrequency, 0);
    float3 wind = float3(
        gradNoise3D(np), 
        gradNoise3D(np + float3(20,20,20)), 
        gradNoise3D(np + float3(100,100,100))
    ) * (_WindStrength * 0.2);  

    // gravity
    float3 leafGravity = _Gravity * _LeafGravity;

    // -- Apply velocity, gravity, and wind first --
    s.currentPos += vel + (leafGravity * _DeltaTime) + wind * _DeltaTime;

    // -- Apply soft spring toward rest position relative to stalk --
    uint leafID = id / _LeafNodesPerLeaf;
    uint nodeInLeaf = id % _LeafNodesPerLeaf;

    if (leafID < _TotalLeafObjects)
    {
        LeafObject lo = _LeafObjectsBuffer[leafID];
        int stalkIdx = lo.stalkNodeIndex;
        if (stalkIdx >= 0 && stalkIdx < _StalkNodesBuffer.Length)
        {
            float3 rootPos = _StalkNodesBuffer[stalkIdx].currentPos;

            // calculate rest direction along stalk
            float3 fwd = float3(0,1,0);
            if (((stalkIdx+1)/_NodesPerStalk) == (stalkIdx/_NodesPerStalk))
            {
                float3 nextPos = _StalkNodesBuffer[stalkIdx+1].currentPos;
                fwd = normalize(nextPos - rootPos);
            }

            float3 tmpUp = abs(fwd.y) > 0.95 ? float3(1,0,0) : float3(0,1,0);
            float3 side = normalize(cross(tmpUp, fwd));
            float3 bin = normalize(cross(fwd, side));

            float ca = cos(lo.angleAroundStem);
            float sa = sin(lo.angleAroundStem);
            float3 around = normalize(side * ca + bin * sa);

            float restLen = _SegmentSpacing * 1.2;
            float3 restPos = rootPos + around * 0.015 + fwd * restLen * nodeInLeaf;

            // spring toward rest position
            float springStiffness = 0.2;
            float t = nodeInLeaf / float(_LeafNodesPerLeaf - 1); // normalize 0..1
            float sFactor = 4.0 * t * (1.0 - t);                // S-curve: 0 at root & tip, max in middle
            float maxSpring = 0.02; // or some small fraction of rest length
            float spring = clamp(spring, -maxSpring, maxSpring);
            s.currentPos += spring * _DeltaTime; 
        }
    }

    // simple seabed collision
    if (s.currentPos.y < 0)
    {
        float3 v2 = s.currentPos - s.previousPos;
        s.currentPos.y = 0;
        v2.y = 0;
        s.previousPos = s.currentPos - v2 * _Damping;
    }

    _LeafSegmentsBuffer[id] = s;
} 

// ---------- LEAF ROPE: Constraints (per segment) ----------
[numthreads(64,1,1)]
void CS_ApplyLeafConstraints(uint id : SV_DispatchThreadID)
{
    if (id >= _LeafSegmentsBuffer.Length) return;

    uint leafID     = id / _LeafNodesPerLeaf;
    uint nodeInLeaf = id % _LeafNodesPerLeaf;
    if (leafID >= _TotalLeafObjects) return;

    LeafObject lo = _LeafObjectsBuffer[leafID];
    int n0 = lo.stalkNodeIndex;
    if (n0 < 0 || n0+1 >= _StalkNodesBuffer.Length) return;

    float3 p0 = _StalkNodesBuffer[n0].currentPos;

    float3 fwd = float3(0,1,0);
    if (((n0+1)/_NodesPerStalk) == (n0/_NodesPerStalk)) {
        float3 p1 = _StalkNodesBuffer[n0+1].currentPos;
        fwd = normalize(p1 - p0);
        if (!all(isfinite(fwd)) || length(fwd)<1e-6) fwd = float3(0,1,0);
    }

    float3 tmpUp = abs(fwd.y) > 0.95 ? float3(1,0,0) : float3(0,1,0);
    float3 side  = normalize(cross(tmpUp, fwd));
    float3 bin   = normalize(cross(fwd, side));

    float ca = cos(lo.angleAroundStem);
    float sa = sin(lo.angleAroundStem);
    float3 around = normalize(side*ca + bin*sa);

    float rest = _SegmentSpacing * 1.2;

    // --- 1. pin the root ---
    if (nodeInLeaf == 0)
    {
        LeafSegment rootSeg = _LeafSegmentsBuffer[id];
        float3 attachPos = p0 + around*0.02;
        rootSeg.currentPos  = attachPos;
		rootSeg.previousPos = attachPos; 
        _LeafSegmentsBuffer[id] = rootSeg;
        return;
    }

    // --- 2. enforce spacing to previous node ---
    int prevID = id - 1;
    LeafSegment prevSeg = _LeafSegmentsBuffer[prevID];
    LeafSegment seg     = _LeafSegmentsBuffer[id];

    float3 d = seg.currentPos - prevSeg.currentPos;
    float dist = length(d);
    if (dist > 1e-6)
    {
        float3 dir = d / dist;
        float diff = dist - rest;
        float3 corr = dir * diff * 0.5;

        prevSeg.currentPos += corr;
        seg.currentPos     -= corr; 
    }
    _LeafSegmentsBuffer[prevID] = prevSeg;
    _LeafSegmentsBuffer[id]     = seg;

    // --- 3. tip drift toward "rest spring line" ---
    if (nodeInLeaf == _LeafNodesPerLeaf - 1)
    {
        float3 tipDir = normalize(seg.currentPos - p0);
        float3 restPos = p0 + tipDir * rest * (_LeafNodesPerLeaf-1); 

        // interpolate toward the rest position
        float driftPower = 0.1; // adjust softness
        seg.currentPos = lerp(seg.currentPos, restPos, driftPower);

        _LeafSegmentsBuffer[id] = seg;
    }

    // --- 4. prevent leaf segment from penetrating stalk ---
    for (int offset = -1; offset <= 1; offset++)
    {
        int stalkCheckIdx = n0 + offset;
        if(stalkCheckIdx < 0 || stalkCheckIdx >= _StalkNodesBuffer.Length) continue;

        float3 stalkPos = _StalkNodesBuffer[stalkCheckIdx].currentPos;
        float3 toLeaf = seg.currentPos - stalkPos;
        float dist = length(toLeaf);
        if(dist < _StemRadius)
        {
            // push leaf segment outside stalk
            float3 push = normalize(toLeaf) * (_StemRadius - dist);
            seg.currentPos += push;
        }
    }
}

// ---------- LEAF ROPE: Update orientation/bend per leaf ----------
[numthreads(64,1,1)]
void CS_UpdateLeaves(uint i : SV_DispatchThreadID)
{
    if (i >= _LeafObjectsBuffer.Length) return;

    uint baseSeg = i * _LeafNodesPerLeaf;
    if (baseSeg + _LeafNodesPerLeaf > _LeafSegmentsBuffer.Length) return; 

    LeafObject lo = _LeafObjectsBuffer[i];

    // Start from root segment
    float3 prevPos = _LeafSegmentsBuffer[baseSeg].currentPos;
    float3 prevDir = float3(0,1,0); // default up

    for (uint j = 1; j < _LeafNodesPerLeaf; ++j)
    {
        uint segIdx = baseSeg + j;
        if (segIdx >= _LeafSegmentsBuffer.Length) break;

        float3 currPos = _LeafSegmentsBuffer[segIdx].currentPos;
        float3 dir = normalize(currPos - prevPos);
        if (!all(isfinite(dir)) || length(dir) < 1e-6)
            dir = prevDir;

        prevDir = dir;
        prevPos = currPos;
    }

    // Store final leaf orientation at root (for instancing)
    float3 tipDir = prevDir;
    lo.orientation = QuatFromTo(float3(0,1,0), tipDir);
    lo.bendAxis = cross(float3(0,1,0), tipDir);
    lo.bendAngle = acos(clamp(dot(float3(0,1,0), tipDir), -1.0, 1.0));

    _LeafObjectsBuffer[i] = lo;
}