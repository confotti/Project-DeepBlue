// === Kernel Declarations ===
#pragma kernel CS_VerletUpdate
#pragma kernel CS_ApplyConstraints

// === Struct Definitions ===
struct StalkNode
{
    float3 currentPos;
    float3 padding0;

    float3 previousPos;
    float3 padding1;

    float3 direction;
    float3 padding2;

    float4 color;
    float bendAmount;
    float3 padding3;

    int isTip;
    float3 padding4;
};

// === Buffers ===
RWStructuredBuffer<StalkNode> _StalkNodesBuffer;

// === Parameters ===
float _DeltaTime;
float3 _Gravity;
float _Damping;
float _SegmentSpacing;
float _Time; 

// === Hashing Function ===
float hash(float3 p)
{
    return frac(sin(dot(p, float3(127.1, 311.7, 74.7))) * 43758.5453);
}

// === Verlet Integration Kernel ===
[numthreads(64,1,1)]
void CS_VerletUpdate(uint id : SV_DispatchThreadID)
{
    if (id >= _StalkNodesBuffer.Length)
        return;

    StalkNode node = _StalkNodesBuffer[id];

    // === Lock the root node (anchor) ===
    if (id == 0)
    {
        node.direction = float3(0, 1, 0);
        node.bendAmount = 0;
        _StalkNodesBuffer[id] = node;
        return;
    }

    // === Verlet integration ===
    float3 velocity = (node.currentPos - node.previousPos) * _Damping;
    node.previousPos = node.currentPos;
    node.currentPos += velocity + (_Gravity * _DeltaTime);

    // === Seabed collision ===
    float seabedHeight = 0.0f;
    if (node.currentPos.y < seabedHeight)
    {
        node.currentPos.y = seabedHeight;
        velocity = node.currentPos - node.previousPos;
        velocity.y = 0;
        node.previousPos = node.currentPos - velocity * _Damping;
    }

    // === Direction and Bend ===
    if (id < _StalkNodesBuffer.Length - 1)
    {
        float3 prevDir = normalize(node.currentPos - _StalkNodesBuffer[id - 1].currentPos);
        float3 nextDir = normalize(_StalkNodesBuffer[id + 1].currentPos - node.currentPos);

        node.direction = normalize(prevDir + nextDir);
        node.bendAmount = length(nextDir - prevDir) * 5.0;
    }
    else
    {
        node.direction = normalize(node.currentPos - _StalkNodesBuffer[id - 1].currentPos);
        node.bendAmount = 0;
    }

    _StalkNodesBuffer[id] = node;
}

// === Constraint Relaxation Kernel ===
[numthreads(64,1,1)]
void CS_ApplyConstraints(uint id : SV_DispatchThreadID)
{
    if (id == 0 || id >= _StalkNodesBuffer.Length) 
        return;

    StalkNode node = _StalkNodesBuffer[id];
    StalkNode prevNode = _StalkNodesBuffer[id - 1];

    float3 delta = node.currentPos - prevNode.currentPos;
    float dist = length(delta);

    if (dist > 0.0001)
    {
        float3 dir = delta / dist;
        float diff = dist - _SegmentSpacing;
        float3 correction = dir * (diff * 0.5); 

        // Apply half correction to both nodes
        node.currentPos -= correction;
        prevNode.currentPos += correction;

        _StalkNodesBuffer[id] = node;
        _StalkNodesBuffer[id - 1] = prevNode;
    }
} 