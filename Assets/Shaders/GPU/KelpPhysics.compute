#pragma kernel CS_StalkUpdate
#pragma kernel CS_LeafUpdate 

struct StalkNode
{
    float3 currentPos;  float pad0;
    float3 previousPos; float pad1;
    float3 direction;   float pad2;
    float4 color;
    float  bendAmount;  float3 pad3;
    int    isTip;       float3 pad4;
};

struct LeafSegment
{
    float3 currentPos;  float pad0;
    float3 previousPos; float pad1;
    float4 color;
};

struct LeafObject
{
    float4 orientation;     
    float3 bendAxis;        
    float  bendAngle;       
    int    stalkNodeIndex;  
    float  angleAroundStem;
    float2 pad;
};

// ---------- Buffers ----------
RWStructuredBuffer<StalkNode>   _StalkNodesBuffer;
StructuredBuffer<float3>        initialRootPositions;

RWStructuredBuffer<LeafSegment> _LeafSegmentsBuffer;  
RWStructuredBuffer<LeafObject>  _LeafObjectsBuffer;

// ---------- Params ----------
float  _DeltaTime;
float3 _Gravity;
float  _Damping;
float  _SegmentSpacing;
float  _Time;
float  _WindStrength;
float  _WindFrequency;
float  _StemRadius;
float  _LeafGravity = 0.47; 

uint   _NodesPerStalk;
uint   _LeafNodesPerLeaf;
uint   _TotalLeafObjects;

// ---------- Noise helpers ----------
float hash(float3 p) { return frac(sin(dot(p, float3(127.1,311.7,74.7))) * 43758.5453); }
uint hashU(uint x){ x = (x ^ 61u) ^ (x >> 16); x *= 9u; x = x ^ (x >> 4); x *= 0x27d4eb2du; x = x ^ (x >> 15); return x; }
static const float3 grad3[12] = {
    float3(1,1,0), float3(-1,1,0), float3(1,-1,0), float3(-1,-1,0),
    float3(1,0,1), float3(-1,0,1), float3(1,0,-1), float3(-1,0,-1),
    float3(0,1,1), float3(0,-1,1), float3(0,1,-1), float3(0,-1,-1)
};
float fade(float t){ return t*t*t*(t*(t*6-15)+10); }
float gradNoise3D(float3 pos){
    int3 pi = (int3)floor(pos);
    float3 pf = pos - floor(pos);
    float u = fade(pf.x), v = fade(pf.y), w = fade(pf.z);
    uint aaa = hashU(hashU(hashU((uint)pi.x)+(uint)pi.y)+(uint)pi.z)%12;
    uint aba = hashU(hashU(hashU((uint)pi.x)+(uint)(pi.y+1))+(uint)pi.z)%12;
    uint aab = hashU(hashU(hashU((uint)pi.x)+(uint)pi.y)+(uint)(pi.z+1))%12;
    uint abb = hashU(hashU(hashU((uint)pi.x)+(uint)(pi.y+1))+(uint)(pi.z+1))%12;
    uint baa = hashU(hashU(hashU((uint)(pi.x+1))+(uint)pi.y)+(uint)pi.z)%12;
    uint bba = hashU(hashU(hashU((uint)(pi.x+1))+(uint)(pi.y+1))+(uint)pi.z)%12;
    uint bab = hashU(hashU(hashU((uint)(pi.x+1))+(uint)pi.y)+(uint)(pi.z+1))%12;
    uint bbb = hashU(hashU(hashU((uint)(pi.x+1))+(uint)(pi.y+1))+(uint)(pi.z+1))%12;
    float3 gaaa=grad3[aaa], gaba=grad3[aba], gaab=grad3[aab], gabb=grad3[abb];
    float3 gbaa=grad3[baa], gbba=grad3[bba], gbab=grad3[bab], gbbb=grad3[bbb];
    float x1 = lerp(dot(gaaa,pf), dot(gbaa,pf-float3(1,0,0)), u);
    float x2 = lerp(dot(gaba,pf-float3(0,1,0)), dot(gbba,pf-float3(1,1,0)), u);
    float y1 = lerp(x1, x2, v);
    float x3 = lerp(dot(gaab,pf-float3(0,0,1)), dot(gbab,pf-float3(1,0,1)), u);
    float x4 = lerp(dot(gabb,pf-float3(0,1,1)), dot(gbbb,pf-float3(1,1,1)), u);
    float y2 = lerp(x3, x4, v);
    return lerp(y1, y2, w);
}

// ---------------- QUAT HELPERS ----------------
float4 QuatFromAxisAngle(float3 axis, float angle){
    float h=angle*0.5; float s=sin(h);
    return float4(axis*s, cos(h));
}
float4 QuatMul(float4 a, float4 b){
    return float4(a.w*b.xyz + b.w*a.xyz + cross(a.xyz,b.xyz), a.w*b.w - dot(a.xyz,b.xyz));
}
float3 QuatRotate(float4 q, float3 v){
    float3 t = 2.0 * cross(q.xyz, v);
    return v + q.w * t + cross(q.xyz, t);
}
float4 QuatFromTo(float3 f, float3 t){
    f = normalize(f); t = normalize(t);
    float c = dot(f,t);
    if(c < -0.9999){
        float3 axis = normalize(cross(float3(0,1,0), f));
        if(!all(isfinite(axis)) || length(axis)<1e-6) axis = normalize(cross(float3(1,0,0), f));
        return QuatFromAxisAngle(axis, 3.14159265);
    }
    float3 axis = cross(f,t);
    float s = sqrt((1+c)*2.0);
    float invs = 1.0/s;
    float4 q = float4(axis*invs, s*0.5);
    return q / sqrt(dot(q,q));
} 

// ---------------- STALK UPDATE ----------------
[numthreads(64,1,1)]
void CS_StalkUpdate(uint id : SV_DispatchThreadID)
{
    if (id >= _StalkNodesBuffer.Length) return;
    StalkNode node = _StalkNodesBuffer[id];

    // pinned root
    if (id % _NodesPerStalk == 0)
    {
        uint stalkIndex = id / _NodesPerStalk;
        float3 rootPos = initialRootPositions[stalkIndex];
        node.currentPos = lerp(node.currentPos, rootPos, 0.9);
        node.previousPos = lerp(node.previousPos, node.currentPos, 0.5);
        node.direction = float3(0,1,0);
        node.bendAmount = 0;
        _StalkNodesBuffer[id] = node;
        return;
    }

    // Verlet integration
    float3 vel = (node.currentPos - node.previousPos) * _Damping;
    node.previousPos = node.currentPos;
    float timeWind = _Time * (_WindFrequency * 0.1);
    float3 np = float3(id * 0.1, 0, 0) + float3(0, timeWind, 0);
    float3 wind = float3(
        gradNoise3D(np),
        gradNoise3D(np + float3(20,20,20)),
        gradNoise3D(np + float3(100,100,100))
    ) * _WindStrength;
    node.currentPos += vel + (_Gravity * _DeltaTime) + wind * _DeltaTime;

    // seabed collision
    if (node.currentPos.y < 0) node.currentPos.y = 0;

    // constraints: only move *this node*, read neighbors
    int prevId = int(id) - 1;
    int nextId = int(id) + 1;
    float3 correction = float3(0,0,0);

    if(prevId >= 0 && (prevId / _NodesPerStalk) == (id / _NodesPerStalk))
    {
        float3 d = node.currentPos - _StalkNodesBuffer[prevId].currentPos;
        float dist = length(d);
        if(dist > 1e-6) correction -= (d / dist) * ((dist - _SegmentSpacing) * 0.5);
    }
    if(nextId < _StalkNodesBuffer.Length && (nextId / _NodesPerStalk) == (id / _NodesPerStalk))
    {
        float3 d = _StalkNodesBuffer[nextId].currentPos - node.currentPos;
        float dist = length(d);
        if(dist > 1e-6) correction += (d / dist) * ((dist - _SegmentSpacing) * 0.5);
    }

    node.currentPos += correction;

    // update direction + bend
    float3 prevDir = (prevId >= 0) ? normalize(node.currentPos - _StalkNodesBuffer[prevId].currentPos) : float3(0,1,0);
    float3 nextDir = (nextId < _StalkNodesBuffer.Length) ? normalize(_StalkNodesBuffer[nextId].currentPos - node.currentPos) : float3(0,1,0);
    node.direction = normalize(lerp(node.direction, normalize(prevDir + nextDir), 0.2));
    node.bendAmount = length(nextDir - prevDir) * 5.0;

    _StalkNodesBuffer[id] = node;
} 

// ---------------- LEAF UPDATE ----------------
[numthreads(64,1,1)]
void CS_LeafUpdate(uint leafID : SV_DispatchThreadID)
{
    if (leafID >= _TotalLeafObjects) return;

    LeafObject lo = _LeafObjectsBuffer[leafID];
    int n0 = lo.stalkNodeIndex;
    if (n0 < 0 || n0 >= _StalkNodesBuffer.Length) return;

    int minStartNode = 5; // 0-indexed, so 2 = third node
	int startNode = max(n0 + minStartNode, minStartNode);
	int endNode = int(n0 + _NodesPerStalk - 2);
	int stalkRange = max(n0, endNode - startNode);

	// Map leaf index proportionally along stalk
	int leafStalkNode = startNode + int( ((float)leafID / (float)_TotalLeafObjects) * stalkRange );
	leafStalkNode = clamp(leafStalkNode, startNode, endNode);
	float3 p0 = _StalkNodesBuffer[lo.stalkNodeIndex].currentPos; 

    uint baseSeg = leafID * _LeafNodesPerLeaf;

    // integrate segments
    for(uint j=0;j<_LeafNodesPerLeaf;j++)
    {
        uint idx = baseSeg + j;
        if(idx >= _LeafSegmentsBuffer.Length) break;
        LeafSegment seg = _LeafSegmentsBuffer[idx];
        float3 vel = (seg.currentPos - seg.previousPos) * _Damping;
        seg.previousPos = seg.currentPos;

        float timeWind = _Time * (_WindFrequency * 0.1);
        float3 np = float3(idx * 0.07, 0, 0) + float3(0, timeWind, 0);
        float3 wind = float3(
            gradNoise3D(np),
            gradNoise3D(np+float3(20,20,20)),
            gradNoise3D(np+float3(100,100,100))
        ) * (_WindStrength*0.5);

        seg.currentPos += vel + (_Gravity*_LeafGravity*_DeltaTime) + wind*_DeltaTime;
        _LeafSegmentsBuffer[idx] = seg;
    }

    // iterative spacing / root attach
    float rest = _SegmentSpacing * 1.2;
    int iters = 1;
    for(int it=0; it<iters; it++)
    {
        uint rootIdx = baseSeg;
        if(rootIdx < _LeafSegmentsBuffer.Length)
        {
            LeafSegment rootSeg = _LeafSegmentsBuffer[rootIdx];

            // attach around stalk with small radius
            float3 attachOffset = float3(cos(lo.angleAroundStem), 0, sin(lo.angleAroundStem)) * 0.02;
            rootSeg.currentPos = lerp(rootSeg.currentPos, p0 + attachOffset, 0.5);
            _LeafSegmentsBuffer[rootIdx] = rootSeg;
        }

        for(uint j=1;j<_LeafNodesPerLeaf;j++)
        {
            uint idx = baseSeg+j;
            uint prevIdx = idx-1;
            if(idx >= _LeafSegmentsBuffer.Length) break;
            LeafSegment seg = _LeafSegmentsBuffer[idx];
            LeafSegment prevSeg = _LeafSegmentsBuffer[prevIdx];

            float3 d = seg.currentPos - prevSeg.currentPos;
            float dist = length(d);
            if(dist > 1e-6)
            {
                float3 corr = d/dist * ((dist - rest)*0.5);
                seg.currentPos -= corr;
                prevSeg.currentPos += corr;
            }
            _LeafSegmentsBuffer[prevIdx] = prevSeg;
            _LeafSegmentsBuffer[idx] = seg;
        }
    }

    // compute leaf orientation
    float3 curPos = p0;
    float3 curDir = float3(0,1,0);
    for(uint j=1;j<_LeafNodesPerLeaf;j++)
    {
        uint idx = baseSeg+j;
        if(idx >= _LeafSegmentsBuffer.Length) break;
        LeafSegment seg = _LeafSegmentsBuffer[idx];
        float3 dir = seg.currentPos - curPos;
        if(length(dir)<1e-6) dir = curDir;
        dir = normalize(dir);
        curDir = dir;
        curPos = seg.currentPos;
    }
    lo.orientation = QuatFromTo(float3(0,1,0), curDir);
    lo.bendAxis = cross(float3(0,1,0), curDir);
    lo.bendAngle = acos(clamp(dot(float3(0,1,0), curDir),-1,1));
    _LeafObjectsBuffer[leafID] = lo;
}