// === Kernel Declarations ===
#pragma kernel CS_VerletUpdate
#pragma kernel CS_ApplyConstraints 
#pragma kernel CS_UpdateLeafNodes 

// === Struct Definitions ===
struct StalkNode
{
    float3 currentPos;
    float padding0;

    float3 previousPos;
    float padding1;

    float3 direction;
    float padding2;

    float4 color;
    float bendAmount;
    float3 padding3;

    int isTip;
    float3 padding4;
};

// === Leaf Structures ===
struct LeafNode
{
    float3 currentPos;
    float padding0;

    float3 previousPos;
    float padding1;

    float4 color; 
};

struct LeafObject
{
    float4 orientation;
    float bendValue;
    int stalkNodeIndex;
	float angleAroundStem; 
    int padding;
};

// === Buffers ===
RWStructuredBuffer<StalkNode> _StalkNodesBuffer;
StructuredBuffer<float3> initialRootPositions; 
RWStructuredBuffer<LeafNode> _LeafNodesBuffer;
StructuredBuffer<LeafObject> _LeafObjectsBuffer; 

// === Parameters ===
float _DeltaTime;
float3 _Gravity;
float _Damping;
float _SegmentSpacing;
float _Time;

float _WindStrength;
float _WindFrequency;

uint _NodesPerStalk; // Number of nodes per stalk, passed from CPU 

// === Hashing Functions ===
// (Same hash and noise functions you had, unchanged)

float hash(float3 p)
{
    return frac(sin(dot(p, float3(127.1, 311.7, 74.7))) * 43758.5453);
}

uint hash(uint x)
{
    x = (x ^ 61u) ^ (x >> 16);
    x *= 9u;
    x = x ^ (x >> 4);
    x *= 0x27d4eb2du;
    x = x ^ (x >> 15);
    return x;
}

static const float3 grad3[12] = {
    float3(1,1,0), float3(-1,1,0), float3(1,-1,0), float3(-1,-1,0),
    float3(1,0,1), float3(-1,0,1), float3(1,0,-1), float3(-1,0,-1),
    float3(0,1,1), float3(0,-1,1), float3(0,1,-1), float3(0,-1,-1)
};

float fade(float t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
}

float gradNoise3D(float3 pos) 
{
    int3 pi = (int3)floor(pos);
    float3 pf = pos - floor(pos);

    float u = fade(pf.x);
    float v = fade(pf.y);
    float w = fade(pf.z);

    uint aaa = hash(hash(hash((uint)pi.x) + (uint)pi.y) + (uint)pi.z) % 12;
    uint aba = hash(hash(hash((uint)pi.x) + (uint)(pi.y + 1)) + (uint)pi.z) % 12;
    uint aab = hash(hash(hash((uint)pi.x) + (uint)pi.y) + (uint)(pi.z + 1)) % 12;
    uint abb = hash(hash(hash((uint)pi.x) + (uint)(pi.y + 1)) + (uint)(pi.z + 1)) % 12;
    uint baa = hash(hash(hash((uint)(pi.x + 1)) + (uint)pi.y) + (uint)pi.z) % 12;
    uint bba = hash(hash(hash((uint)(pi.x + 1)) + (uint)(pi.y + 1)) + (uint)pi.z) % 12;
    uint bab = hash(hash(hash((uint)(pi.x + 1)) + (uint)pi.y) + (uint)(pi.z + 1)) % 12;
    uint bbb = hash(hash(hash((uint)(pi.x + 1)) + (uint)(pi.y + 1)) + (uint)(pi.z + 1)) % 12;

    float3 gaaa = grad3[aaa];
    float3 gaba = grad3[aba];
    float3 gaab = grad3[aab];
    float3 gabb = grad3[abb];
    float3 gbaa = grad3[baa];
    float3 gbba = grad3[bba];
    float3 gbab = grad3[bab];
    float3 gbbb = grad3[bbb];

    float x1 = lerp(dot(gaaa, pf), dot(gbaa, pf - float3(1, 0, 0)), u);
    float x2 = lerp(dot(gaba, pf - float3(0, 1, 0)), dot(gbba, pf - float3(1, 1, 0)), u);
    float y1 = lerp(x1, x2, v);

    float x3 = lerp(dot(gaab, pf - float3(0, 0, 1)), dot(gbab, pf - float3(1, 0, 1)), u);
    float x4 = lerp(dot(gabb, pf - float3(0, 1, 1)), dot(gbbb, pf - float3(1, 1, 1)), u);
    float y2 = lerp(x3, x4, v);

    return lerp(y1, y2, w);
}

// === Verlet Integration Kernel ===
[numthreads(64,1,1)]
void CS_VerletUpdate(uint id : SV_DispatchThreadID)
{
    if (id >= _StalkNodesBuffer.Length)
        return;

    StalkNode node = _StalkNodesBuffer[id];

    // Root node initialization per stalk
    if (id % _NodesPerStalk == 0)
    {
        uint stalkIndex = id / _NodesPerStalk;
        node.currentPos = initialRootPositions[stalkIndex];
        node.previousPos = node.currentPos;
        node.direction = float3(0, 1, 0);
        node.bendAmount = 0;
        _StalkNodesBuffer[id] = node;
        return;
    } 

    // Verlet integration
    float3 velocity = (node.currentPos - node.previousPos) * _Damping;
    node.previousPos = node.currentPos;

	// Clamp velocity magnitude (example max speed)
	float maxSpeed = 0.1;
	float speed = length(velocity);
	if(speed > maxSpeed)
	{
		velocity = normalize(velocity) * maxSpeed; 
	}

    // Wind force using smooth noise
    float3 noisePos = float3(id * 0.1, 0, 0) + float3(0, _Time * _WindFrequency, 0); 
    float noiseX = gradNoise3D(noisePos);
    float noiseY = gradNoise3D(noisePos + float3(100, 100, 100));
    float noiseZ = gradNoise3D(noisePos + float3(200, 200, 200));
    float3 windForce = float3(noiseX, noiseY, noiseZ) * _WindStrength;

    node.currentPos += velocity + (_Gravity * _DeltaTime) + windForce * _DeltaTime;

    // Seabed collision
    float seabedHeight = 0.0f;
    if (node.currentPos.y < seabedHeight)
    {
        node.currentPos.y = seabedHeight;

        // Dampen vertical velocity on collision
        velocity = node.currentPos - node.previousPos;
        velocity.y = 0;
        node.previousPos = node.currentPos - velocity * _Damping;
    }

    // Update direction between neighbors (handle stalk boundaries)
    float3 prevDir;
    float3 nextDir;

    // Ensure neighbors are within the same stalk
    bool hasPrev = (id % _NodesPerStalk) != 0;
    bool hasNext = ((id + 1) % _NodesPerStalk) != 0 && (id + 1) < _StalkNodesBuffer.Length;

    if (hasPrev && hasNext)
    {
        prevDir = normalize(node.currentPos - _StalkNodesBuffer[id - 1].currentPos);
        nextDir = normalize(_StalkNodesBuffer[id + 1].currentPos - node.currentPos);
    }
    else if (hasPrev)
    {
        prevDir = normalize(node.currentPos - _StalkNodesBuffer[id - 1].currentPos);
        nextDir = prevDir;
    }
    else if (hasNext)
    {
        prevDir = normalize(_StalkNodesBuffer[id + 1].currentPos - node.currentPos);
        nextDir = prevDir;
    }
    else
    {
        prevDir = float3(0,1,0);
        nextDir = float3(0,1,0);
    }

    float3 targetDir = normalize(prevDir + nextDir);
    float smoothingFactor = 0.2;
    node.direction = normalize(lerp(node.direction, targetDir, smoothingFactor));
    node.bendAmount = length(nextDir - prevDir) * 5.0;

    _StalkNodesBuffer[id] = node;
}
 
// === Constraint Relaxation Kernel ===
// Enforces fixed distance (_SegmentSpacing) between consecutive nodes on the same stalk
[numthreads(64,1,1)]
void CS_ApplyConstraints(uint id : SV_DispatchThreadID)
{
    if (id >= _StalkNodesBuffer.Length) 
        return;

    // Skip root nodes, they are fixed
    if (id % _NodesPerStalk == 0)
        return;

    StalkNode node = _StalkNodesBuffer[id];
    StalkNode prevNode = _StalkNodesBuffer[id - 1];

    // Ensure prevNode is on the same stalk (id-1 is valid if same stalk)
    if ((id / _NodesPerStalk) != ((id - 1) / _NodesPerStalk))
        return;

    float3 delta = node.currentPos - prevNode.currentPos; 
    float dist = length(delta);
    float diff = dist - _SegmentSpacing;

    if (abs(diff) > 0.0001)
    {
        float3 correction = normalize(delta) * diff * 0.5;

        // Move current node back
        node.currentPos -= correction;

        // Move previous node forward unless root node (id-1 % _NodesPerStalk == 0)
        if ((id - 1) % _NodesPerStalk != 0)
        {
            prevNode.currentPos += correction;
            _StalkNodesBuffer[id - 1] = prevNode;
        }

        _StalkNodesBuffer[id] = node;
    }
} 

[numthreads(64,1,1)]
void CS_UpdateLeafNodes(uint id : SV_DispatchThreadID)
{
    if (id >= _LeafNodesBuffer.Length) 
        return;

    LeafObject leafObj = _LeafObjectsBuffer[id];
    LeafNode leafNode = _LeafNodesBuffer[id];

    int stalkIndex = leafObj.stalkNodeIndex;
    if (stalkIndex < 0 || stalkIndex >= _StalkNodesBuffer.Length)
        return;

    StalkNode stalkNode = _StalkNodesBuffer[stalkIndex];
    float3 stalkPos = stalkNode.currentPos;

    // Offset radius from the stem
    float radius = 0.05; // adjust to control how far from stem the leaves appear

    // Calculate offset position in circle around stalk node
    float angle = leafObj.angleAroundStem;
    float3 offset = float3(cos(angle), 0, sin(angle)) * radius;

    // Assign leaf position with offset around the stalk node
    leafNode.currentPos = stalkPos + offset;

    // For previousPos, just keep the same (or lerp if you want smoothing)
    leafNode.previousPos = leafNode.currentPos;

    // You can set leaf color or other properties as before
    leafNode.color = leafNode.color;

    _LeafNodesBuffer[id] = leafNode; 
} 